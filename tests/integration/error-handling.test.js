/**
 * Error Handling Integration Tests
 * Tests comprehensive error handling across the application
 */

const request = require('supertest');
const app = require('../../examples/05-swarm-apps/rest-api-advanced/server');
const { errors, tokens } = require('../fixtures/test-data');\n\ndescribe('Error Handling Integration Tests', () => {\n  describe('Authentication Errors', () => {\n    it('should return 401 for missing authorization header', async () => {\n      const response = await request(app)\n        .get('/api/auth/profile')\n        .expect(401);\n\n      expect(response.body).toMatchObject({\n        success: false,\n        error: expect.stringContaining('token')\n      });\n    });\n\n    it('should return 401 for invalid token format', async () => {\n      const response = await request(app)\n        .get('/api/auth/profile')\n        .set('Authorization', 'InvalidTokenFormat')\n        .expect(401);\n\n      expect(response.body).toMatchObject({\n        success: false,\n        error: expect.stringContaining('token')\n      });\n    });\n\n    it('should return 401 for malformed JWT', async () => {\n      const response = await request(app)\n        .get('/api/auth/profile')\n        .set('Authorization', `Bearer ${tokens.malformed}`)\n        .expect(401);\n\n      expect(response.body).toMatchObject({\n        success: false,\n        error: expect.stringContaining('token')\n      });\n    });\n\n    it('should return 401 for expired token', async () => {\n      const response = await request(app)\n        .get('/api/auth/profile')\n        .set('Authorization', `Bearer ${tokens.expired}`)\n        .expect(401);\n\n      expect(response.body).toMatchObject({\n        success: false,\n        error: expect.stringContaining('expired')\n      });\n    });\n  });\n\n  describe('Validation Errors', () => {\n    it('should return 400 for invalid registration data', async () => {\n      const invalidData = {\n        email: 'invalid-email',\n        password: '123', // Too short\n        name: '' // Empty\n      };\n\n      const response = await request(app)\n        .post('/api/auth/register')\n        .send(invalidData)\n        .expect(400);\n\n      expect(response.body).toMatchObject({\n        success: false,\n        error: expect.any(String)\n      });\n    });\n\n    it('should return 400 for missing required fields', async () => {\n      const response = await request(app)\n        .post('/api/auth/register')\n        .send({})\n        .expect(400);\n\n      expect(response.body).toMatchObject({\n        success: false,\n        error: expect.any(String)\n      });\n    });\n\n    it('should return 400 for invalid email format', async () => {\n      const invalidData = {\n        email: 'not-an-email',\n        password: 'ValidPassword123!',\n        name: 'Valid Name'\n      };\n\n      const response = await request(app)\n        .post('/api/auth/register')\n        .send(invalidData)\n        .expect(400);\n\n      expect(response.body).toMatchObject({\n        success: false,\n        error: expect.stringContaining('email')\n      });\n    });\n\n    it('should return 400 for weak password', async () => {\n      const invalidData = {\n        email: 'valid@example.com',\n        password: 'weak',\n        name: 'Valid Name'\n      };\n\n      const response = await request(app)\n        .post('/api/auth/register')\n        .send(invalidData)\n        .expect(400);\n\n      expect(response.body).toMatchObject({\n        success: false,\n        error: expect.stringContaining('password')\n      });\n    });\n  });\n\n  describe('Authorization Errors', () => {\n    let userToken;\n\n    beforeEach(async () => {\n      // Create and login a regular user\n      await request(app)\n        .post('/api/auth/register')\n        .send({\n          email: 'testuser@example.com',\n          password: 'TestPassword123!',\n          name: 'Test User'\n        });\n\n      const loginResponse = await request(app)\n        .post('/api/auth/login')\n        .send({\n          email: 'testuser@example.com',\n          password: 'TestPassword123!'\n        });\n\n      userToken = loginResponse.body.data.token;\n    });\n\n    it('should return 403 for insufficient permissions', async () => {\n      // Assuming there's an admin-only endpoint\n      const response = await request(app)\n        .get('/api/admin/users')\n        .set('Authorization', `Bearer ${userToken}`)\n        .expect(403);\n\n      expect(response.body).toMatchObject({\n        success: false,\n        error: expect.stringMatching(/(permission|access|forbidden)/i)\n      });\n    });\n  });\n\n  describe('Not Found Errors', () => {\n    it('should return 404 for non-existent endpoints', async () => {\n      const response = await request(app)\n        .get('/api/non-existent-endpoint')\n        .expect(404);\n\n      expect(response.body).toMatchObject({\n        success: false,\n        error: expect.stringMatching(/(not found|endpoint)/i)\n      });\n    });\n\n    it('should return 404 for non-existent resources', async () => {\n      const response = await request(app)\n        .get('/api/users/999999999999999999999999') // Non-existent ID\n        .expect(404);\n\n      expect(response.body).toMatchObject({\n        success: false,\n        error: expect.stringMatching(/(not found|resource)/i)\n      });\n    });\n  });\n\n  describe('Rate Limiting Errors', () => {\n    it('should return 429 after exceeding rate limit', async () => {\n      const requests = [];\n      const maxRequests = 100; // Assuming rate limit is lower\n\n      // Make many requests in quick succession\n      for (let i = 0; i < maxRequests; i++) {\n        requests.push(\n          request(app)\n            .post('/api/auth/login')\n            .send({\n              email: 'test@example.com',\n              password: 'wrongpassword'\n            })\n        );\n      }\n\n      const responses = await Promise.allSettled(requests);\n      \n      // At least some should be rate limited\n      const rateLimited = responses.filter(\n        r => r.status === 'fulfilled' && r.value.status === 429\n      );\n\n      expect(rateLimited.length).toBeGreaterThan(0);\n      \n      if (rateLimited.length > 0) {\n        expect(rateLimited[0].value.body).toMatchObject({\n          success: false,\n          error: expect.stringMatching(/(rate limit|too many)/i)\n        });\n      }\n    }, 30000);\n  });\n\n  describe('Database Errors', () => {\n    it('should handle database connection errors gracefully', async () => {\n      // This test would require temporarily breaking the DB connection\n      // For now, we'll test that the error response format is correct\n      \n      // Mock a database error scenario by using invalid data that would cause a DB error\n      const response = await request(app)\n        .post('/api/auth/register')\n        .send({\n          email: 'test@example.com'.repeat(100), // Extremely long email to cause DB error\n          password: 'ValidPassword123!',\n          name: 'Test User'\n        });\n\n      // Should return 500 or 400 depending on how the error is handled\n      expect([400, 500]).toContain(response.status);\n      expect(response.body).toMatchObject({\n        success: false,\n        error: expect.any(String)\n      });\n    });\n  });\n\n  describe('Duplicate Resource Errors', () => {\n    beforeEach(async () => {\n      // Create a user to test duplicate scenarios\n      await request(app)\n        .post('/api/auth/register')\n        .send({\n          email: 'existing@example.com',\n          password: 'ExistingPassword123!',\n          name: 'Existing User'\n        });\n    });\n\n    it('should return 400 for duplicate email registration', async () => {\n      const response = await request(app)\n        .post('/api/auth/register')\n        .send({\n          email: 'existing@example.com', // Same email\n          password: 'DifferentPassword123!',\n          name: 'Different User'\n        })\n        .expect(400);\n\n      expect(response.body).toMatchObject({\n        success: false,\n        error: expect.stringMatching(/(already exists|duplicate|email)/i)\n      });\n    });\n  });\n\n  describe('Content Type Errors', () => {\n    it('should return 400 for invalid JSON', async () => {\n      const response = await request(app)\n        .post('/api/auth/register')\n        .set('Content-Type', 'application/json')\n        .send('{invalid json}')\n        .expect(400);\n\n      expect(response.body).toMatchObject({\n        success: false,\n        error: expect.stringMatching(/(json|parse|syntax)/i)\n      });\n    });\n\n    it('should return 415 for unsupported media type', async () => {\n      const response = await request(app)\n        .post('/api/auth/register')\n        .set('Content-Type', 'text/plain')\n        .send('plain text data')\n        .expect(415);\n\n      expect(response.body).toMatchObject({\n        success: false,\n        error: expect.stringMatching(/(media type|content type)/i)\n      });\n    });\n  });\n\n  describe('Method Not Allowed Errors', () => {\n    it('should return 405 for unsupported HTTP methods', async () => {\n      const response = await request(app)\n        .patch('/api/auth/login') // PATCH not supported for login\n        .expect(405);\n\n      expect(response.body).toMatchObject({\n        success: false,\n        error: expect.stringMatching(/(method|not allowed)/i)\n      });\n    });\n  });\n\n  describe('Server Errors', () => {\n    it('should handle uncaught exceptions gracefully', async () => {\n      // This would test global error handlers\n      // Implementation depends on how the app handles uncaught exceptions\n      \n      // For now, test that error responses have consistent format\n      const response = await request(app)\n        .get('/api/trigger-error') // Assuming this endpoint exists for testing\n        .expect(500);\n\n      expect(response.body).toMatchObject({\n        success: false,\n        error: expect.any(String)\n      });\n      \n      // Should not expose internal error details in production\n      expect(response.body.error).not.toMatch(/stack trace|internal|debug/i);\n    });\n  });\n\n  describe('Custom Error Classes', () => {\n    it('should properly format validation errors', () => {\n      const error = errors.validation;\n      \n      expect(error).toMatchObject({\n        name: 'ValidationError',\n        message: expect.any(String),\n        errors: expect.arrayContaining([\n          expect.objectContaining({\n            field: expect.any(String),\n            message: expect.any(String)\n          })\n        ])\n      });\n    });\n\n    it('should properly format authentication errors', () => {\n      const error = errors.authentication;\n      \n      expect(error).toMatchObject({\n        name: 'AuthenticationError',\n        message: expect.any(String),\n        statusCode: 401\n      });\n    });\n\n    it('should properly format authorization errors', () => {\n      const error = errors.authorization;\n      \n      expect(error).toMatchObject({\n        name: 'AuthorizationError',\n        message: expect.any(String),\n        statusCode: 403\n      });\n    });\n  });\n\n  describe('Error Logging', () => {\n    it('should log errors appropriately', async () => {\n      // Mock the logger to verify errors are logged\n      const consoleSpy = jest.spyOn(console, 'error').mockImplementation(() => {});\n      \n      await request(app)\n        .post('/api/auth/login')\n        .send({\n          email: 'nonexistent@example.com',\n          password: 'wrongpassword'\n        })\n        .expect(401);\n\n      // Verify that error was logged (implementation may vary)\n      // expect(consoleSpy).toHaveBeenCalled();\n      \n      consoleSpy.mockRestore();\n    });\n  });\n\n  describe('Security Headers', () => {\n    it('should include security headers in error responses', async () => {\n      const response = await request(app)\n        .get('/api/non-existent')\n        .expect(404);\n\n      // Check for common security headers\n      expect(response.headers).toMatchObject({\n        'x-content-type-options': 'nosniff',\n        'x-frame-options': expect.any(String),\n        'x-xss-protection': expect.any(String)\n      });\n    });\n\n    it('should not expose sensitive information in error messages', async () => {\n      const response = await request(app)\n        .get('/api/users/invalid-id')\n        .expect(400);\n\n      // Error message should not contain sensitive internal information\n      expect(response.body.error).not.toMatch(/(password|token|secret|key|database|internal)/i);\n    });\n  });\n});"